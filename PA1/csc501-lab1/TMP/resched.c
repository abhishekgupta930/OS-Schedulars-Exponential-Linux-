/* resched.c  -  resched */

#include <conf.h>
#include <kernel.h>
#include <math.h>
#include <proc.h>
#include <q.h>
#include <sched.h>
#define RAND_MAX 077777

// int  expdev(double lambda);

unsigned long currSP; /* REAL sp of current process */
extern int ctxsw(int, int, int, int);
int proc_id_next;
/*-----------------------------------------------------------------------
 * resched  --  reschedule processor to highest priority ready process
 *
 * Notes:	Upon entry, currpid gives current process id.
 *		Proctab[currpid].pstate gives correct NEXT state for
 *			current process if other than PRREADY.
 *------------------------------------------------------------------------
 */

// New scheduling mechanism
int resched() {

  register struct pentry *optr; /* pointer to old process entry */
  register struct pentry *nptr; /* pointer to new process entry */
  int nextpid;
  double rand_prio;

  optr = &proctab[currpid];

  if (scheduler == EXPDISTSCHED) {

    if (optr->pstate == PRCURR) {
      optr->pstate = PRREADY;
      insert(currpid, rdyhead, optr->pprio);
    }

    // Obtaining the exponentialally distributed random variablei

    rand_prio = expdev(0.1);

    // Based upon the random variable generated by exp scheduler algorithm get
    // process id of process to be scheduled

    proc_id_next = get_next_process4expscheduler(&rand_prio);

    if (proc_id_next == EMPTY)
      nextpid = NULLPROC;
    else
      nextpid = dequeue(proc_id_next);

    // kprintf("The value of currpid = %d \n",(int)rand_prio);

    currpid = nextpid;
    nptr = &proctab[nextpid];
    nptr->pstate = PRCURR;
#ifdef RTCLOCK
    preempt = QUANTUM;
#endif
    ctxsw((int)&optr->pesp, (int)optr->pirmask, (int)&nptr->pesp,
          (int)nptr->pirmask);
    return OK;

  }

  else if (scheduler == LINUXSCHED) {

    //kprintf("\n resched(): Curr Pid = %d\n", currpid);
    int max_goodness, next;
    //kprintf("pre-empt = %d \n", preempt);

    // Set goodness and counter value to zero if process exhausted its quantum.
    // Else remaining clock ticks will be carried over to new epoch or later 
    // in the same epoch
    if (preempt <= 0) {
      optr->goodness = 0;
      optr->counter = 0;
    }

    else
      optr->counter = preempt;

    
    // Push the process into ready Queue
    if (optr->pstate == PRCURR) {
      optr->pstate = PRREADY;
      // kprintf("\n Before adding to ready Queue\n");
      insert(currpid, rdyhead, optr->goodness);
    }

    // The value of max goodness. If max goodness is zero
    // it means the current epoch has ended.
    getMaxGoodnessProcess(&next, &max_goodness);

    // For new Epoch update goodness and quantum
    if (max_goodness == 0 && preempt <= 0) {
      //kprintf("\n\n --------------In New Epoch--------------\n\n");
      updateGoodness_Value();

      nptr = &proctab[NULLPROC];
      nptr->pstate = PRCURR;
      dequeue(NULLPROC);
      currpid = NULLPROC;
#ifdef RTCLOCK
      preempt = QUANTUM;
#endif
      ctxsw((int)&optr->pesp, (int)optr->pirmask, (int)&nptr->pesp,
            (int)nptr->pirmask);
      return OK;

    }

    // If not new Epoch
    else {
      if (currpid != NULLPROC) {
            updateGoodness();
      }
    }

    // Get the process with Max goodness value.
    getMaxGoodnessProcess(&next, &max_goodness);
    nptr = &proctab[next];
    //kprintf("\nNext Sch ProcID =%d \n", next);
    nptr->pstate = PRCURR;
    currpid = next;
    dequeue(next);

#ifdef RTCLOCK
    // preempt = QUANTUM;              /* reset preemption counter     */
#endif
    if (currpid == NULLPROC)
      preempt = QUANTUM;
    else
      preempt = nptr->counter;
    //

    ctxsw((int)&optr->pesp, (int)optr->pirmask, (int)&nptr->pesp,
          (int)nptr->pirmask);
    return OK;

  }

  else {

    // Default Xinu Scheduler
    /* no switch needed if current process priority higher than next*/

    if (((optr = &proctab[currpid])->pstate == PRCURR) &&
        (lastkey(rdytail) < optr->pprio)) {
      return (OK);
    }

    /* force context switch */

    if (optr->pstate == PRCURR) {
      optr->pstate = PRREADY;
      insert(currpid, rdyhead, optr->pprio);
    }

    /* remove highest priority process at end of ready list */
    nptr = &proctab[(currpid = getlast(rdytail))];
    nptr->pstate = PRCURR; /* mark it currently running	*/
#ifdef RTCLOCK
    preempt = QUANTUM; /* reset preemption counter	*/
#endif

    ctxsw((int)&optr->pesp, (int)optr->pirmask, (int)&nptr->pesp,
          (int)nptr->pirmask);
    return OK;
  }

  /* The OLD process returns here when resumed. */
}
